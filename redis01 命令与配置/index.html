<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="pandaaaaaa">





<title>redis01 命令与配置 | pandaaaaaa&#39;s blogs</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">pandaaaaaa&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">pandaaaaaa&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">redis01 命令与配置</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">pandaaaaaa</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">April 29, 2020&nbsp;&nbsp;18:39:14</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Redis/">Redis</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="NoSql概述"><a href="#NoSql概述" class="headerlink" title="NoSql概述"></a>NoSql概述</h2><p>NoSql：Not Only SQL，不仅仅是sql，泛指非关系型数据库。</p>
<p>NoSQL 不依赖业务逻辑方式存储，以简单的key-value模式存储。</p>
<p>NoSql的特点：</p>
<ul>
<li>不遵循SQL标准。</li>
<li>不支持ACID。</li>
<li>有远超于SQL的性能。</li>
</ul>
<p>NoSql适用场景：对数据高并发的读写、海量数据的读写、对数据高可扩展性的</p>
<p>不适用场景：需要事务支持的、基于sql的结构化查询存储，处理复杂的关系,需要即席查询（用户自定义查询条件）。</p>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://juejin.im/post/5b6d62ddf265da0f491bd200" target="_blank" rel="noopener">NoSQL 还是 SQL ？这一篇讲清楚</a></p>
<h2 id="redis概述"><a href="#redis概述" class="headerlink" title="redis概述"></a>redis概述</h2><p>Redis是一个开源的key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。与memcached一样，为了保证效率，<strong>数据都是缓存在内存中</strong>。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<p>安装较为简单略去，查看默认安装目录 /usr/local/bin：</p>
<ol>
<li>Redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何(服务启动起来后执行)</li>
<li>Redis-check-aof：修复有问题的AOF文件</li>
<li>Redis-check-dump：修复有问题的dump.rdb文件</li>
<li>Redis-sentinel：Redis集群使用</li>
<li>redis-server：Redis服务器启动命令</li>
<li>redis-cli：客户端，操作入口</li>
</ol>
<h3 id="开启与关闭"><a href="#开启与关闭" class="headerlink" title="开启与关闭"></a>开启与关闭</h3><p>启动方式：<code>redis-server [配置文件位置]</code> 默认使用前台启动，在配置文件redis.conf中更改daemonize=yes代表后台启动并在启动时指定配置文件，默认无配置文件启动。多端口启动时使用<code>-p</code>指定端口，docker中需将该值设为no，否则无法启动容器。</p>
<p>关闭实例：<code>redis-cli [-p post] shutdown</code>或进入客户端程序，使用<code>shutdown</code>关闭。</p>
<p>连通性测试：使用命令<code>ping</code>。</p>
<p>redis默认端口为6379为影星Alessia <em>Merz</em>的九键数字。</p>
<p>redis默认16个数据库，可以使用命令<code>select index</code>来选择相应的库，这里的index从0开始，类似数组下标。</p>
<p>redis的密码：16个库使用同一个密码，连接后使用<code>auth passwd</code>进行认证，才能操作数据。</p>
<h3 id="Redis的单线程-多路IO复用技术"><a href="#Redis的单线程-多路IO复用技术" class="headerlink" title="Redis的单线程+多路IO复用技术"></a>Redis的单线程+多路IO复用技术</h3><p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p>
<h3 id="Memcached与redis区别"><a href="#Memcached与redis区别" class="headerlink" title="Memcached与redis区别"></a>Memcached与redis区别</h3><ol>
<li>Memcached不持久化，redis支持两种持久化策略rdb和aof。</li>
<li>Memcached存储简单的key-value，redis支持5种存储类型（这里的5种都对应value）。</li>
<li>Memcached使用多线程 + 锁的机制，Redis使用单线程 + 多路IO复用。</li>
</ol>
<h2 id="redis中的key和五大数据类型"><a href="#redis中的key和五大数据类型" class="headerlink" title="redis中的key和五大数据类型"></a>redis中的key和五大数据类型</h2><p><img src="https://s1.ax1x.com/2020/04/29/J7wsyT.png" alt="image-20200427172425965"></p>
<p>这里的五种数据类型是依据value的类型来说的。</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>关于key的操作：</p>
<table>
<thead>
<tr>
<th>关于key的操作：</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>keys  *</code></td>
<td>查看当前库的所有键</td>
</tr>
<tr>
<td><code>exists &lt;key&gt;</code></td>
<td>判断某个键是否存在</td>
</tr>
<tr>
<td><code>type &lt;key&gt;</code></td>
<td>查看值的类型</td>
</tr>
<tr>
<td><code>del &lt;key&gt;</code></td>
<td>删除某个键</td>
</tr>
<tr>
<td><code>expire &lt;key&gt;  &lt;seconds&gt;</code></td>
<td>为键值设置过期时间，单位秒</td>
</tr>
<tr>
<td><code>ttl &lt;key&gt;</code></td>
<td>查看还有多久过期,-1表示永不过期,-2表示已过期</td>
</tr>
<tr>
<td><code>dbsize</code></td>
<td>查看当前数据库中key的数量</td>
</tr>
<tr>
<td><code>flushdb</code></td>
<td>清空当前库</td>
</tr>
<tr>
<td><code>flushall</code></td>
<td>通杀全部库</td>
</tr>
</tbody></table>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul>
<li>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</li>
<li>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</li>
<li>String类型是Redis最基本的数据类型，一个Redis中字符串value最大为512M。</li>
</ul>
<table>
<thead>
<tr>
<th>string常用操作</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>get &lt;key&gt;</code></td>
<td>查询对应键值</td>
</tr>
<tr>
<td><code>set &lt;key&gt; &lt;value&gt;</code></td>
<td>添加键值对</td>
</tr>
<tr>
<td><code>append &lt;key&gt; &lt;value&gt;</code></td>
<td>将给定的<code>&lt;value&gt;</code>追加到原值的末尾，返回值添加后长度</td>
</tr>
<tr>
<td><code>strlen &lt;key&gt;</code></td>
<td>获取值的长度</td>
</tr>
<tr>
<td><code>setnx &lt;key&gt; &lt;value&gt;</code></td>
<td>只有在key 不存在时设置key的值，return：否插入成功</td>
</tr>
<tr>
<td><code>incr &lt;key&gt;</code></td>
<td>将key中存储的数字值增1  只能对数字值操作，如果为空，新增值为1 return增长后值</td>
</tr>
<tr>
<td><code>decr &lt;key&gt;</code></td>
<td>将key中存储的数字值减1  只能对数字值操作，如果为空，新增值为-1</td>
</tr>
<tr>
<td><code>incrby /decrby &lt;key&gt; 步长</code></td>
<td>将key中存储的数字值增减，自定义步长（可为负） return：增长后值</td>
</tr>
<tr>
<td><code>mset &lt;key1&gt; &lt;value1&gt; &lt;key2&gt;  &lt;value2&gt;</code></td>
<td>同时设置一个或多个key-value对</td>
</tr>
<tr>
<td><code>mget &lt;key1&gt; &lt;key2&gt; &lt;key3&gt;</code></td>
<td>同时获取一个或多个value</td>
</tr>
<tr>
<td><code>msetnx &lt;key1&gt; &lt;value1&gt; &lt;key2&gt;  &lt;value2&gt;</code></td>
<td>同时设置一个或多个key-value对，当且仅当所有给定的key都不存在</td>
</tr>
<tr>
<td><code>getrange &lt;key&gt; &lt;起始位置&gt; &lt;结束位置&gt;</code></td>
<td>获得值的范围[m,n],类似java中的substring，范围不同</td>
</tr>
<tr>
<td><code>setrange &lt;key&gt; &lt;起始位置&gt; &lt;value&gt;</code></td>
<td>用<code>&lt;value&gt;</code>从&lt;起始位置&gt;开始覆盖<code>&lt;key&gt;</code>所存储的字符串值 return：更改后值</td>
</tr>
<tr>
<td><code>setex &lt;key&gt; &lt;过期时间&gt; &lt;value</code></td>
<td>设置键值的同时，设置过去时间，单位秒</td>
</tr>
<tr>
<td><code>getset &lt;key&gt; &lt;value&gt;</code></td>
<td>以新换旧,设置了新值的同时获取旧值</td>
</tr>
</tbody></table>
<p>详说 incr key 操作的原子性：</p>
<ul>
<li>所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。</li>
<li>在单线程中， 能够在单条指令中完成的操作都可以认为是” 原子操作”，因为中断只能发生于指令之间。</li>
<li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</li>
<li>Redis单命令的原子性主要得益于Redis的单线程</li>
</ul>
<p>思考: java中i++是否是原子操作?非原子性</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>单键多值，有序。Redis列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素导列表的头部（左边）或者尾部（右边）。它的底层实际是个<strong>双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差</strong>。</p>
<table>
<thead>
<tr>
<th>list常用操作</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>lpush/rpush &lt;key&gt; &lt;value1&gt; &lt;value2&gt;</code></td>
<td>从左边(倒序)/右边(正序)插入一个或多个值。</td>
</tr>
<tr>
<td><code>lpop/rpop &lt;key&gt;</code></td>
<td>从左边/右边吐出一个值。  值在键在，值光键亡。</td>
</tr>
<tr>
<td><code>rpoplpush &lt;key1&gt; &lt;key2&gt;</code></td>
<td>从<code>&lt;key1&gt;</code>列表右边吐出一个值，插到<code>&lt;key2&gt;</code>列表左边</td>
</tr>
<tr>
<td><code>lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</code></td>
<td>按照索引下标获得元素(从左到右) <code>lrange key 0 -1</code>来查看list中所有值</td>
</tr>
<tr>
<td><code>lindex &lt;key&gt; &lt;index&gt;</code></td>
<td>按照索引下标获得元素(从左到右)</td>
</tr>
<tr>
<td><code>llen &lt;key&gt;</code></td>
<td>获得列表长度</td>
</tr>
<tr>
<td>`linsert <key> before</td>
<td>after <value> <newvalue>`</td>
</tr>
<tr>
<td><code>lrem &lt;key&gt; &lt;n&gt;   &lt;value&gt;</code></td>
<td>从左边删除n个value(从左到右)</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lpush k1 v1 v2 v3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; rpush k2 v1 v2 v3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; type k1</span><br><span class="line">list</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lrange k1 0 -1</span><br><span class="line">1) "v3"</span><br><span class="line">2) "v2"</span><br><span class="line">3) "v1"</span><br><span class="line">127.0.0.1:6379&gt; lrange k2 0 -1</span><br><span class="line">1) "v1"</span><br><span class="line">2) "v2"</span><br><span class="line">3) "v3"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lpop k2</span><br><span class="line">"v1"</span><br><span class="line">127.0.0.1:6379&gt; lrange k2 0 -1</span><br><span class="line">1) "v2"</span><br><span class="line">2) "v3"</span><br><span class="line">127.0.0.1:6379&gt; rpop k2</span><br><span class="line">"v3"</span><br><span class="line">127.0.0.1:6379&gt; lrange k2 0 -1</span><br><span class="line">1) "v2"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lindex k1 2</span><br><span class="line">"v1"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; llen k1</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; linsert k2 before v2 v1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; linsert k2 after v2 v3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange k2 0 -1</span><br><span class="line">1) "v1"</span><br><span class="line">2) "v2"</span><br><span class="line">3) "v3"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; rpush k3 1 1 1 2 1 2 1</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; lrem k3 4 1</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange k3 0 -1</span><br><span class="line">1) "2"</span><br><span class="line">2) "2"</span><br><span class="line">3) "1"</span><br><span class="line">127.0.0.1:6379&gt; lrem k3 4 2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange k3 0 -1</span><br><span class="line">1) "1"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p> Redis的Set是string类型的无序不重复集合。它底层其实是一个value为null的hash表,所以添加，删除，查找的复杂度都是O(1)。并且提供了判断某个成员是否在一个set集合内的重要接口。同list值在键在，值无键亡。</p>
<table>
<thead>
<tr>
<th>set常用操作</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>sadd &lt;key&gt;   &lt;value1&gt; &lt;value2&gt;  ....</code></td>
<td>将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。</td>
</tr>
<tr>
<td><code>smembers &lt;key&gt;</code></td>
<td>取出该集合的所有值。</td>
</tr>
<tr>
<td><code>sismember &lt;key&gt;   &lt;value&gt;</code></td>
<td>判断集合<code>&lt;key&gt;</code>是否为含有该<code>&lt;value&gt;</code>值，有返回1，没有返回0</td>
</tr>
<tr>
<td><code>scard  &lt;key&gt;</code></td>
<td>返回该集合的元素个数。</td>
</tr>
<tr>
<td><code>srem &lt;key&gt; &lt;value1&gt; &lt;value2&gt; ....</code></td>
<td>删除集合中的某个元素。</td>
</tr>
<tr>
<td><code>spop &lt;key&gt;</code></td>
<td>随机从该集合中吐出一个值。</td>
</tr>
<tr>
<td><code>srandmember &lt;key&gt; &lt;n&gt;</code></td>
<td>随机从该集合中取出n个值。  不会从集合中删除</td>
</tr>
<tr>
<td><code>sinter &lt;key1&gt; &lt;key2&gt;</code></td>
<td>返回两个集合的交集元素。</td>
</tr>
<tr>
<td><code>sunion &lt;key1&gt; &lt;key2&gt;</code></td>
<td>返回两个集合的并集元素。</td>
</tr>
<tr>
<td><code>sdiff &lt;key1&gt; &lt;key2&gt;</code></td>
<td>返回两个集合的差集元素。</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; sadd k1 v1 v2 v1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; type k1</span><br><span class="line">set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; smembers k1</span><br><span class="line">1) "v1"</span><br><span class="line">2) "v2"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd k1 v1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; sismember k1 v1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember k1 v3</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; scard k1</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; srem k1 v1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers k1</span><br><span class="line">1) "v2"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; spop k1</span><br><span class="line">"v2"</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd k1 v1 v2 v1 v3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers k1</span><br><span class="line">1) "v3"</span><br><span class="line">2) "v1"</span><br><span class="line">3) "v2"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; srandmember k1 2</span><br><span class="line">1) "v1"</span><br><span class="line">2) "v3"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd k2 v1 v2 v4 v5</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sinter k1 k2</span><br><span class="line">1) "v1"</span><br><span class="line">2) "v2"</span><br><span class="line">127.0.0.1:6379&gt; sunion k1 k2</span><br><span class="line">1) "v5"</span><br><span class="line">2) "v2"</span><br><span class="line">3) "v3"</span><br><span class="line">4) "v1"</span><br><span class="line">5) "v4"</span><br><span class="line">127.0.0.1:6379&gt; sdiff k1 k2</span><br><span class="line">1) "v3"</span><br><span class="line">127.0.0.1:6379&gt; sdiff k2 k1</span><br><span class="line">1) "v4"</span><br><span class="line">2) "v5"</span><br></pre></td></tr></table></figure>

<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>Redis  hash 是一个键值对集合，是string类型的field和value的映射表，hash适合用于存储对象。类似Java里面的Map&lt;String,String&gt;</p>
<p>分析一个问题: 现有一个简单JavaBean对象，在Redis中如何存?</p>
<ol>
<li>序列化后使用string存储；序列化与反序列化，开销大</li>
<li>对象标识+属性名为键，属性值为值使用string存储；数据冗余</li>
<li>使用hash</li>
</ol>
<table>
<thead>
<tr>
<th>hash常用操作</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</code></td>
<td>给<code>&lt;key&gt;</code>集合中的 <code>&lt;field&gt;</code>键赋值<code>&lt;value&gt;</code></td>
</tr>
<tr>
<td><code>hget &lt;key1&gt; &lt;field&gt;</code></td>
<td>从<code>&lt;key1&gt;</code>集合<code>&lt;field&gt;</code>取出 value</td>
</tr>
<tr>
<td><code>hmset &lt;key1&gt; &lt;field1&gt;  &lt;value1&gt; &lt;field2&gt; &lt;value2&gt;...</code></td>
<td>批量设置hash的值</td>
</tr>
<tr>
<td><code>hexists key &lt;field&gt;</code></td>
<td>查看哈希表 key 中，给定域 field 是否存在。</td>
</tr>
<tr>
<td><code>hkeys &lt;key&gt;</code></td>
<td>列出该hash集合的所有field</td>
</tr>
<tr>
<td><code>hvals &lt;key&gt;</code></td>
<td>列出该hash集合的所有value</td>
</tr>
<tr>
<td><code>hincrby &lt;key&gt; &lt;field&gt;   &lt;increment&gt;</code></td>
<td>为哈希表 key 中的域 field 的值加上增量 increment</td>
</tr>
<tr>
<td><code>hsetnx &lt;key&gt; &lt;field&gt;  &lt;value&gt;</code></td>
<td>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user name xiaoming age 12 phone 123 addr newyork</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; hget user name</span><br><span class="line">"xiaoming"</span><br><span class="line">127.0.0.1:6379&gt; hkeys user</span><br><span class="line">1) "name"</span><br><span class="line">2) "age"</span><br><span class="line">3) "phone"</span><br><span class="line">4) "addr"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hexists user name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists user names</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hvals user</span><br><span class="line">1) "xiaoming"</span><br><span class="line">2) "12"</span><br><span class="line">3) "123"</span><br><span class="line">4) "newyork"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hincrby user age 1</span><br><span class="line">(integer) 13</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hsetnx user lastname wang</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hsetnx user lastname wang</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>zset与普通集合set非常相似，是一个没有重复元素的字符串集合。不同之处是有序集合的每个成员都关联了一个评分（score） ，这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。因为元素是有序的, 所以可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<table>
<thead>
<tr>
<th>zset常用操作</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>zadd &lt;key&gt; &lt;score1&gt;  &lt;value1&gt; &lt;score2&gt;  &lt;value2&gt;...</code></td>
<td>将一个或多个 member 元素及其 score 值加入到有序集 key 当中</td>
</tr>
<tr>
<td><code>zrange &lt;key&gt; &lt;start&gt;  &lt;stop&gt; [WITHSCORES]</code></td>
<td>返回有序集 key 中，<strong>下标在<code>&lt;start&gt;</code> <code>&lt;stop&gt;</code>之间</strong>的元素  带WITHSCORES，可以让分数一起和值返回到结果集。</td>
</tr>
<tr>
<td><code>zrangebyscore key min max [withscores] [limit offset count]</code></td>
<td>返回有序集 key 中，<strong>所有score 值介于 min 和 max 之间(包括等于 min 或 max)</strong> 的成员。有序集成员按 score 值递增(从小到大)次序排列。</td>
</tr>
<tr>
<td><code>zrevrangebyscore key max min [withscores] [limit offset count]</code></td>
<td>同上，改为从大到小排列。</td>
</tr>
<tr>
<td><code>zincrby &lt;key&gt; &lt;increment&gt; &lt;value&gt;</code></td>
<td>为元素的score加上增量</td>
</tr>
<tr>
<td><code>zrem &lt;key&gt; &lt;value&gt;</code></td>
<td>删除该集合下，指定值的元素</td>
</tr>
<tr>
<td><code>zcount &lt;key&gt;   &lt;min&gt; &lt;max&gt;</code></td>
<td>统计该集合，分数区间内的元素个数</td>
</tr>
<tr>
<td><code>zrank &lt;key&gt; &lt;value&gt;</code></td>
<td>返回该值在集合中的排名，从0开始。</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; zadd k1 10 n1 0 v2 100 v3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange k1 0 -1</span><br><span class="line">1) "v2"</span><br><span class="line">2) "n1"</span><br><span class="line">3) "v3"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore k1 0 10</span><br><span class="line">1) "v2"</span><br><span class="line">2) "n1"</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore k1 0 2</span><br><span class="line">1) "v2"</span><br><span class="line">127.0.0.1:6379&gt; zrange k1 0 2</span><br><span class="line">1) "v2"</span><br><span class="line">2) "n1"</span><br><span class="line">3) "v3"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrevrangebyscore k1 0 10</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; zrevrangebyscore k1 10 0</span><br><span class="line">1) "n1"</span><br><span class="line">2) "v2"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zincrby k1 10 n1</span><br><span class="line">"20"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrem k1 n1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange k1 0 -1</span><br><span class="line">1) "v2"</span><br><span class="line">2) "v3"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zcount k1 0 -1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zcount k1 0 100</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zadd k1 -20 v1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange k1 0 -1</span><br><span class="line">1) "v1"</span><br><span class="line">2) "v2"</span><br><span class="line">3) "v3"</span><br><span class="line">127.0.0.1:6379&gt; zrank k1 v3</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<h2 id="redis常用配置"><a href="#redis常用配置" class="headerlink" title="redis常用配置"></a>redis常用配置</h2><p>配置文件中大小写不敏感</p>
<h3 id="计量单位说明"><a href="#计量单位说明" class="headerlink" title="计量单位说明"></a>计量单位说明</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Note on units: when memory size is needed, it is possible to specify</span></span><br><span class="line"><span class="comment"># it in the usual form of 1k 5GB 4M and so forth:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1k =&gt; 1000 bytes</span></span><br><span class="line"><span class="comment"># 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="comment"># 1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="comment"># 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="comment"># 1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="comment"># 1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span><br></pre></td></tr></table></figure>

<h3 id="INCLUDES包含配置"><a href="#INCLUDES包含配置" class="headerlink" title="INCLUDES包含配置"></a>INCLUDES包含配置</h3><ul>
<li>include：类似jsp中的include，多实例的情况可以把公用的配置文件提取出来，各自的配置文件中仅需要做特定配置并include公共文件即可。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################## INCLUDES ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include one or more other config files here.  This is useful if you</span></span><br><span class="line"><span class="comment"># have a standard template that goes to all Redis servers but also need</span></span><br><span class="line"><span class="comment"># to customize a few per-server settings.  Include files can include</span></span><br><span class="line"><span class="comment"># other files, so use this wisely.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Notice option "include" won't be rewritten by command "CONFIG REWRITE"</span></span><br><span class="line"><span class="comment"># from admin or Redis Sentinel. Since Redis always uses the last processed</span></span><br><span class="line"><span class="comment"># line as value of a configuration directive, you'd better put includes</span></span><br><span class="line"><span class="comment"># at the beginning of this file to avoid overwriting config change at runtime.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If instead you are interested in using includes to override configuration</span></span><br><span class="line"><span class="comment"># options, it is better to use include as the last line.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># include /path/to/local.conf</span></span><br><span class="line"><span class="comment"># include /path/to/other.conf</span></span><br></pre></td></tr></table></figure>

<h3 id="NETWORK网络配置"><a href="#NETWORK网络配置" class="headerlink" title="NETWORK网络配置"></a>NETWORK网络配置</h3><ul>
<li>ip地址的绑定 bind，默认情况bind=127.0.0.1只能接受本机的访问请求，不写的情况下，无限制接受任何ip地址的访问，生产环境肯定要写你应用服务器的地址，如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，只接受本机访问。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################## NETWORK #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default, if no "bind" configuration directive is specified, Redis listens</span></span><br><span class="line"><span class="comment"># for connections from all the network interfaces available on the server.</span></span><br><span class="line"><span class="comment"># It is possible to listen to just one or multiple selected interfaces using</span></span><br><span class="line"><span class="comment"># the "bind" configuration directive, followed by one or more IP addresses.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Examples:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># bind 192.168.1.100 10.0.0.1</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1 ::1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the</span></span><br><span class="line"><span class="comment"># internet, binding to all the interfaces is dangerous and will expose the</span></span><br><span class="line"><span class="comment"># instance to everybody on the internet. So by default we uncomment the</span></span><br><span class="line"><span class="comment"># following bind directive, that will force Redis to listen only into</span></span><br><span class="line"><span class="comment"># the IPv4 loopback interface address (this means Redis will be able to</span></span><br><span class="line"><span class="comment"># accept connections only from clients running into the same computer it</span></span><br><span class="line"><span class="comment"># is running).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span></span><br><span class="line"><span class="comment"># JUST COMMENT THE FOLLOWING LINE.</span></span><br><span class="line"><span class="comment"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># Protected mode is a layer of security protection, in order to avoid that</span></span><br><span class="line"><span class="comment"># Redis instances left open on the internet are accessed and exploited.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When protected mode is on and if:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) The server is not binding explicitly to a set of addresses using the</span></span><br><span class="line"><span class="comment">#    "bind" directive.</span></span><br><span class="line"><span class="comment"># 2) No password is configured.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The server only accepts connections from clients connecting from the</span></span><br><span class="line"><span class="comment"># IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</span></span><br><span class="line"><span class="comment"># sockets.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default protected mode is enabled. You should disable it only if</span></span><br><span class="line"><span class="comment"># you are sure you want clients from other hosts to connect to Redis</span></span><br><span class="line"><span class="comment"># even if no authentication is configured, nor a specific set of interfaces</span></span><br><span class="line"><span class="comment"># are explicitly listed using the "bind" directive.</span></span><br><span class="line"><span class="meta">protected-mode</span> <span class="string">no</span></span><br></pre></td></tr></table></figure>

<ul>
<li>port进程启动端口</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Accept connections on the specified port, default is 6379 (IANA #815344).</span></span><br><span class="line"><span class="comment"># If port 0 is specified Redis will not listen on a TCP socket.</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br></pre></td></tr></table></figure>

<ul>
<li>tcp-backlog：可以理解为一个请求到达后至到接受进程处理前的队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列，高并发环境tcp-backlog设置值由超时时限内的Redis吞吐量决定</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TCP listen() backlog.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In high requests-per-second environments you need an high backlog in order</span></span><br><span class="line"><span class="comment"># to avoid slow clients connections issues. Note that the Linux kernel</span></span><br><span class="line"><span class="comment"># will silently truncate it to the value of /proc/sys/net/core/somaxconn so</span></span><br><span class="line"><span class="comment"># make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span></span><br><span class="line"><span class="comment"># in order to get the desired effect.</span></span><br><span class="line"><span class="meta">tcp-backlog</span> <span class="string">511</span></span><br></pre></td></tr></table></figure>

<ul>
<li>timeout：一个空闲的客户端维持多少秒会关闭，0为永不关闭。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Unix socket.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Specify the path for the Unix socket that will be used to listen for</span></span><br><span class="line"><span class="comment"># incoming connections. There is no default, so Redis will not listen</span></span><br><span class="line"><span class="comment"># on a unix socket when not specified.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># unixsocket /tmp/redis.sock</span></span><br><span class="line"><span class="comment"># unixsocketperm 700</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Close the connection after a client is idle for N seconds (0 to disable)</span></span><br><span class="line"><span class="attr">timeout</span> <span class="string">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>tcp-keepalive：对访问客户端的一种心跳检测，每个n秒检测一次，官方推荐设置为60秒</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TCP keepalive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</span></span><br><span class="line"><span class="comment"># of communication. This is useful for two reasons:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) Detect dead peers.</span></span><br><span class="line"><span class="comment"># 2) Take the connection alive from the point of view of network</span></span><br><span class="line"><span class="comment">#    equipment in the middle.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># On Linux, the specified value (in seconds) is the period used to send ACKs.</span></span><br><span class="line"><span class="comment"># Note that to close the connection the double of the time is needed.</span></span><br><span class="line"><span class="comment"># On other kernels the period depends on the kernel configuration.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A reasonable value for this option is 300 seconds, which is the new</span></span><br><span class="line"><span class="comment"># Redis default starting with Redis 3.2.1.</span></span><br><span class="line"><span class="meta">tcp-keepalive</span> <span class="string">300</span></span><br></pre></td></tr></table></figure>

<h3 id="GENERAL常规设置"><a href="#GENERAL常规设置" class="headerlink" title="GENERAL常规设置"></a>GENERAL常规设置</h3><ul>
<li>daemonize：是否为后台进程</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># By default Redis does not run as a daemon. Use 'yes' if you need it.</span></span><br><span class="line"><span class="comment"># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">no</span></span><br></pre></td></tr></table></figure>

<ul>
<li>pidfile：存放pid文件的位置，每个实例会产生一个不同的pid文件</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If a pid file is specified, Redis writes it where specified at startup</span></span><br><span class="line"><span class="comment"># and removes it at exit.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When the server runs non daemonized, no pid file is created if none is</span></span><br><span class="line"><span class="comment"># specified in the configuration. When the server is daemonized, the pid file</span></span><br><span class="line"><span class="comment"># is used even if not specified, defaulting to "/var/run/redis.pid".</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Creating a pid file is best effort: if Redis is not able to create it</span></span><br><span class="line"><span class="comment"># nothing bad happens, the server will start and run normally.</span></span><br><span class="line"><span class="attr">pidfile</span> <span class="string">/var/run/redis_6379.pid</span></span><br></pre></td></tr></table></figure>

<ul>
<li>log level：四个级别根据使用阶段来选择，生产环境选择notice 或者warning</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Specify the server verbosity level.</span></span><br><span class="line"><span class="comment"># This can be one of:</span></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably)</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line"><span class="attr">loglevel</span> <span class="string">notice</span></span><br></pre></td></tr></table></figure>

<ul>
<li>logfile：日志文件名称</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Specify the log file name. Also the empty string can be used to force</span></span><br><span class="line"><span class="comment"># Redis to log on the standard output. Note that if you use standard</span></span><br><span class="line"><span class="comment"># output for logging but daemonize, logs will be sent to /dev/null</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">""</span></span><br></pre></td></tr></table></figure>

<ul>
<li>syslog-enabled：是否将Redis日志输送到linux系统日志服务中</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To enable logging to the system logger, just set 'syslog-enabled' to yes,</span></span><br><span class="line"><span class="comment"># and optionally update the other syslog parameters to suit your needs.</span></span><br><span class="line"><span class="comment"># syslog-enabled no</span></span><br></pre></td></tr></table></figure>

<ul>
<li>syslog-ident：日志的标志</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Specify the syslog identity.</span></span><br><span class="line"><span class="comment"># syslog-ident redis</span></span><br></pre></td></tr></table></figure>

<ul>
<li>syslog-facility：输出日志的设备</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span></span><br><span class="line"><span class="comment"># syslog-facility local0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>database：设定库的数量 默认16</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set the number of databases. The default database is DB 0, you can select</span></span><br><span class="line"><span class="comment"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span></span><br><span class="line"><span class="comment"># dbid is a number between 0 and 'databases'-1</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">16</span></span><br></pre></td></tr></table></figure>

<ul>
<li>always-show-logo图标显示</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># By default Redis shows an ASCII art logo only when started to log to the</span></span><br><span class="line"><span class="comment"># standard output and if the standard output is a TTY. Basically this means</span></span><br><span class="line"><span class="comment"># that normally a logo is displayed only in interactive sessions.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However it is possible to force the pre-4.0 behavior and always show a</span></span><br><span class="line"><span class="comment"># ASCII art logo in startup logs by setting the following option to yes.</span></span><br><span class="line"><span class="meta">always-show-logo</span> <span class="string">yes</span></span><br></pre></td></tr></table></figure>

<h3 id="SNAPSHOTTING快照配置"><a href="#SNAPSHOTTING快照配置" class="headerlink" title="SNAPSHOTTING快照配置"></a>SNAPSHOTTING快照配置</h3><p>参考持久化部分内容</p>
<h3 id="REPLICATION主从复制配置"><a href="#REPLICATION主从复制配置" class="headerlink" title="REPLICATION主从复制配置"></a>REPLICATION主从复制配置</h3><p>参考主从赋值部分</p>
<h3 id="SECURITY安全配置"><a href="#SECURITY安全配置" class="headerlink" title="SECURITY安全配置"></a>SECURITY安全配置</h3><ul>
<li>requirepass：在命令行中设置密码，此密码所有库统一</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other</span></span><br><span class="line"><span class="comment"># commands.  This might be useful in environments in which you do not trust</span></span><br><span class="line"><span class="comment"># others with access to the host running redis-server.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This should stay commented out for backward compatibility and because most</span></span><br><span class="line"><span class="comment"># people do not need auth (e.g. they run their own servers).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Warning: since Redis is pretty fast an outside user can try up to</span></span><br><span class="line"><span class="comment"># 150k passwords per second against a good box. This means that you should</span></span><br><span class="line"><span class="comment"># use a very strong password otherwise it will be very easy to break.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">foobared</span></span><br></pre></td></tr></table></figure>

<h3 id="CLIENTS客户端相关配置"><a href="#CLIENTS客户端相关配置" class="headerlink" title="CLIENTS客户端相关配置"></a>CLIENTS客户端相关配置</h3><ul>
<li>maxclient：最大客户端连接数</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set the max number of connected clients at the same time. By default</span></span><br><span class="line"><span class="comment"># this limit is set to 10000 clients, however if the Redis server is not</span></span><br><span class="line"><span class="comment"># able to configure the process file limit to allow for the specified limit</span></span><br><span class="line"><span class="comment"># the max number of allowed clients is set to the current file limit</span></span><br><span class="line"><span class="comment"># minus 32 (as Redis reserves a few file descriptors for internal uses).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Once the limit is reached Redis will close all the new connections sending</span></span><br><span class="line"><span class="comment"># an error 'max number of clients reached'.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxclients 10000</span></span><br></pre></td></tr></table></figure>

<h3 id="MEMORY-MANAGEMENT内存管理配置"><a href="#MEMORY-MANAGEMENT内存管理配置" class="headerlink" title="MEMORY MANAGEMENT内存管理配置"></a>MEMORY MANAGEMENT内存管理配置</h3><ul>
<li>maxmemory：设置Redis可以使用的内存量。一旦到达内存使用上限，Redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。如果Redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么Redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If Redis can't remove keys according to the policy, or if the policy is</span></span><br><span class="line"><span class="comment"># set to 'noeviction', Redis will start to reply with errors to commands</span></span><br><span class="line"><span class="comment"># that would use more memory, like SET, LPUSH, and so on, and will continue</span></span><br><span class="line"><span class="comment"># to reply to read-only commands like GET.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This option is usually useful when using Redis as an LRU or LFU cache, or to</span></span><br><span class="line"><span class="comment"># set a hard memory limit for an instance (using the 'noeviction' policy).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># WARNING: If you have replicas attached to an instance with maxmemory on,</span></span><br><span class="line"><span class="comment"># the size of the output buffers needed to feed the replicas are subtracted</span></span><br><span class="line"><span class="comment"># from the used memory count, so that network problems / resyncs will</span></span><br><span class="line"><span class="comment"># not trigger a loop where keys are evicted, and in turn the output</span></span><br><span class="line"><span class="comment"># buffer of replicas is full with DELs of keys evicted triggering the deletion</span></span><br><span class="line"><span class="comment"># of more keys, and so forth until the database is completely emptied.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In short... if you have replicas attached it is suggested that you set a lower</span></span><br><span class="line"><span class="comment"># limit for maxmemory so that there is some free RAM on the system for replica</span></span><br><span class="line"><span class="comment"># output buffers (but this is not needed if the policy is 'noeviction').</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxmemory &lt;bytes&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Maxmemory-policy：<ul>
<li>volatile-lru：使用LRU算法（最近最少使用）移除key，只对设置了过期时间的键</li>
<li>allkeys-lru：使用LRU（最不常用）算法移除key</li>
<li>volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</li>
<li>allkeys-random：移除随机的key</li>
<li>volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</li>
<li>noeviction：不进行移除。针对写操作，只是返回错误信息</li>
</ul>
</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span></span><br><span class="line"><span class="comment"># is reached. You can select among five behaviors:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.</span></span><br><span class="line"><span class="comment"># allkeys-lru -&gt; Evict any key using approximated LRU.</span></span><br><span class="line"><span class="comment"># volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set.</span></span><br><span class="line"><span class="comment"># allkeys-lfu -&gt; Evict any key using approximated LFU.</span></span><br><span class="line"><span class="comment"># volatile-random -&gt; Remove a random key among the ones with an expire set.</span></span><br><span class="line"><span class="comment"># allkeys-random -&gt; Remove a random key, any key.</span></span><br><span class="line"><span class="comment"># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span></span><br><span class="line"><span class="comment"># noeviction -&gt; Don't evict anything, just return an error on write operations.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># LRU means Least Recently Used</span></span><br><span class="line"><span class="comment"># LFU means Least Frequently Used</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Both LRU, LFU and volatile-ttl are implemented using approximated</span></span><br><span class="line"><span class="comment"># randomized algorithms.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> with any of the above policies, Redis will return an error on write</span></span><br><span class="line"><span class="comment">#       operations, when there are no suitable keys for eviction.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       At the date of writing these commands are: set setnx setex append</span></span><br><span class="line"><span class="comment">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span></span><br><span class="line"><span class="comment">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span></span><br><span class="line"><span class="comment">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span></span><br><span class="line"><span class="comment">#       getset mset msetnx exec sort</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxmemory-policy noeviction</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Maxmemory-samples：设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小。一般设置3到7的数字，数值越小样本越不准确，但是性能消耗也越小。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span></span><br><span class="line"><span class="comment"># algorithms (in order to save memory), so you can tune it for speed or</span></span><br><span class="line"><span class="comment"># accuracy. For default Redis will check five keys and pick the one that was</span></span><br><span class="line"><span class="comment"># used less recently, you can change the sample size using the following</span></span><br><span class="line"><span class="comment"># configuration directive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default of 5 produces good enough results. 10 Approximates very closely</span></span><br><span class="line"><span class="comment"># true LRU but costs more CPU. 3 is faster but not very accurate.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxmemory-samples 5</span></span><br></pre></td></tr></table></figure>

<h2 id="Java客户端Jedis"><a href="#Java客户端Jedis" class="headerlink" title="Java客户端Jedis"></a>Java客户端Jedis</h2><p>jedis的使用比较简单，调用函数也与redis命令同名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"39.106.221.71"</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">"foobared"</span>);</span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h2><h3 id="redis中事务的定义"><a href="#redis中事务的定义" class="headerlink" title="redis中事务的定义"></a>redis中事务的定义</h3><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。Redis事务的主要作用就是串联多个命令防止别的命令插队。</p>
<p>简单来说就是：顺序执行一组语句，可被打断，打断后不回滚。</p>
<h3 id="multi-、exec、discard"><a href="#multi-、exec、discard" class="headerlink" title="multi 、exec、discard"></a>multi 、exec、discard</h3><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，至到输入Exec后，Redis会将之前的命令队列中的命令依次执行。</p>
<p>组队的过程中可以通过discard来放弃组队。</p>
<p><img src="https://s1.ax1x.com/2020/04/29/J7wrlV.png" alt="image-20200428233358772"></p>
<h3 id="事务中的错误处理"><a href="#事务中的错误处理" class="headerlink" title="事务中的错误处理"></a>事务中的错误处理</h3><p>组队中某个命令出现了报告错误，执行时整个的所有队列会都会被取消。</p>
<p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p>
<p><img src="https://s1.ax1x.com/2020/04/29/J7wyOU.png" alt="image-20200428233455214"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; sadd k3 v1 v2 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; spop k3</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这是由于smembers命令的语法错误，将在调用EXEC之前被检测出来，并终止事务</span></span><br><span class="line">127.0.0.1:6379&gt; smember k3</span><br><span class="line">(error) ERR unknown command `smember`, with args beginning with: `k3`, </span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p>
<p><img src="https://s1.ax1x.com/2020/04/29/J7wcmF.png" alt="image-20200428233520047"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; sadd k3 v1 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; smembers k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) (integer) 2</span><br><span class="line">2) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">3) 1) "v1"</span><br><span class="line">   2) "v2"</span><br></pre></td></tr></table></figure>

<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p> 悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。</p>
<h3 id="Redis事务的使用"><a href="#Redis事务的使用" class="headerlink" title="Redis事务的使用"></a>Redis事务的使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WATCH key[key….]</span><br></pre></td></tr></table></figure>

<p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unwatch</span><br></pre></td></tr></table></figure>

<p>取消<code>WATCH</code>命令对<strong>所有 key</strong>的监视。如果在执行<code>WATCH</code>命令之后，<code>EXEC</code>命令或<code>DISCARD</code>命令先被执行了的话，那么就不需要再执行<code>UNWATCH</code>了。</p>
<h3 id="三特性"><a href="#三特性" class="headerlink" title="三特性"></a>三特性</h3><p>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题 </p>
<p>不保证原子性：Redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</p>
<h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><p>Redis 提供了2个不同形式的持久化方式。</p>
<ul>
<li>RDB （Redis DataBase）</li>
<li>AOF （Append Of File）</li>
</ul>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>在指定的时间间隔内将内存中的<strong>数据集快照</strong>写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>
<p>手动保存快照：</p>
<ul>
<li>save: 只管保存，其它不管，全部阻塞</li>
<li>bgsave:按照保存策略自动保存</li>
</ul>
<h4 id="备份是如何执行的"><a href="#备份是如何执行的" class="headerlink" title="备份是如何执行的"></a>备份是如何执行的</h4><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>
<blockquote>
<p>关于fork:在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“写时复制技术”，一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p>
</blockquote>
<h4 id="相应配置"><a href="#相应配置" class="headerlink" title="相应配置"></a>相应配置</h4><ul>
<li>dbfilename：RDB保存的文件名，在redis.conf中配置文件名称，默认为dump.rdb</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The filename where to dump the DB</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb</span></span><br></pre></td></tr></table></figure>

<ul>
<li>dir：RDB文件的保存路径，默认为Redis启动时命令行所在的目录下,也可以修改</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The working directory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The DB will be written inside this directory, with the filename specified</span></span><br><span class="line"><span class="comment"># above using the 'dbfilename' configuration directive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Append Only File will also be created inside this directory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that you must specify a directory here, not a file name.</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./</span></span><br></pre></td></tr></table></figure>

<ul>
<li>save：rdb的保存策略</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Save the DB on disk:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Will save the DB if both the given number of seconds and the given</span></span><br><span class="line"><span class="comment">#   number of write operations against the DB occurred.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   In the example below the behaviour will be to save:</span></span><br><span class="line"><span class="comment">#   after 900 sec (15 min) if at least 1 key changed</span></span><br><span class="line"><span class="comment">#   after 300 sec (5 min) if at least 10 keys changed</span></span><br><span class="line"><span class="comment">#   after 60 sec if at least 10000 keys changed</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   <span class="doctag">Note:</span> you can disable saving completely by commenting out all "save" lines.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   It is also possible to remove all the previously configured save</span></span><br><span class="line"><span class="comment">#   points by adding a save directive with a single empty string argument</span></span><br><span class="line"><span class="comment">#   like in the following example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   save ""</span></span><br><span class="line"></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1</span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10</span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>stop-writes-on-bgsave-error：当Redis无法写入磁盘的话，直接关掉Redis的写操作</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># By default Redis will stop accepting writes if RDB snapshots are enabled</span></span><br><span class="line"><span class="comment"># (at least one save point) and the latest background save failed.</span></span><br><span class="line"><span class="comment"># This will make the user aware (in a hard way) that data is not persisting</span></span><br><span class="line"><span class="comment"># on disk properly, otherwise chances are that no one will notice and some</span></span><br><span class="line"><span class="comment"># disaster will happen.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the background saving process will start working again Redis will</span></span><br><span class="line"><span class="comment"># automatically allow writes again.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However if you have setup your proper monitoring of the Redis server</span></span><br><span class="line"><span class="comment"># and persistence, you may want to disable this feature so that Redis will</span></span><br><span class="line"><span class="comment"># continue to work as usual even if there are problems with disk,</span></span><br><span class="line"><span class="comment"># permissions, and so forth.</span></span><br><span class="line"><span class="meta">stop-writes-on-bgsave-error</span> <span class="string">yes</span></span><br></pre></td></tr></table></figure>

<ul>
<li>rdbcompression：进行rdb保存时，将文件压缩</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compress string objects using LZF when dump .rdb databases?</span></span><br><span class="line"><span class="comment"># For default that's set to 'yes' as it's almost always a win.</span></span><br><span class="line"><span class="comment"># If you want to save some CPU in the saving child set it to 'no' but</span></span><br><span class="line"><span class="comment"># the dataset will likely be bigger if you have compressible values or keys.</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br></pre></td></tr></table></figure>

<ul>
<li>rdbchecksum：在存储快照后，还可以让Redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span></span><br><span class="line"><span class="comment"># This makes the format more resistant to corruption but there is a performance</span></span><br><span class="line"><span class="comment"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span></span><br><span class="line"><span class="comment"># for maximum performances.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># RDB files created with checksum disabled have a checksum of zero that will</span></span><br><span class="line"><span class="comment"># tell the loading code to skip the check.</span></span><br><span class="line"><span class="attr">rdbchecksum</span> <span class="string">yes</span></span><br></pre></td></tr></table></figure>

<h4 id="RDB的备份与恢复"><a href="#RDB的备份与恢复" class="headerlink" title="RDB的备份与恢复"></a>RDB的备份与恢复</h4><p>备份：先通过config get dir 查询rdb文件的目录 , 将*.rdb的文件拷贝到别的地方。</p>
<p>恢复：关闭Redis，把备份的文件拷贝到工作目录下,启动redis,备份数据会直接加载。</p>
<h4 id="RDB的优缺点"><a href="#RDB的优缺点" class="headerlink" title="RDB的优缺点"></a>RDB的优缺点</h4><ul>
<li>优点: 节省磁盘空间,恢复速度快。</li>
<li>缺点: 虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。     在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>以日志的形式来记录每个写操作，<strong>将Redis执行过的所有写指令记录下来(读操作不记录)</strong>，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<h4 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h4><ul>
<li>appendonly：<strong>AOF默认不开启</strong>，需要手动在配置文件中配置</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The Append Only File is an alternative persistence mode that provides</span></span><br><span class="line"><span class="comment"># much better durability. For instance using the default data fsync policy</span></span><br><span class="line"><span class="comment"># (see later in the config file) Redis can lose just one second of writes in a</span></span><br><span class="line"><span class="comment"># dramatic event like a server power outage, or a single write if something</span></span><br><span class="line"><span class="comment"># wrong with the Redis process itself happens, but the operating system is</span></span><br><span class="line"><span class="comment"># still running correctly.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># AOF and RDB persistence can be enabled at the same time without problems.</span></span><br><span class="line"><span class="comment"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span></span><br><span class="line"><span class="comment"># with the better durability guarantees.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please check http://redis.io/topics/persistence for more information.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">no</span></span><br></pre></td></tr></table></figure>

<ul>
<li>appendfilename：aof文件名称，默认为 appendonly.aof，AOF文件的保存路径，同RDB的路径一致。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The name of the append only file (default: "appendonly.aof")</span></span><br><span class="line"></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">"appendonly.aof"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>AOF同步频率设置<ul>
<li>always始终同步，每次Redis的写入都会立刻记入日志</li>
<li>everysec每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</li>
<li>no不主动进行同步，把同步时机交给操作系统。</li>
</ul>
</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The fsync() call tells the Operating System to actually write data on disk</span></span><br><span class="line"><span class="comment"># instead of waiting for more data in the output buffer. Some OS will really flush</span></span><br><span class="line"><span class="comment"># data on disk, some other OS will just try to do it ASAP.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Redis supports three different modes:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># no: don't fsync, just let the OS flush the data when it wants. Faster.</span></span><br><span class="line"><span class="comment"># always: fsync after every write to the append only log. Slow, Safest.</span></span><br><span class="line"><span class="comment"># everysec: fsync only one time every second. Compromise.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is "everysec", as that's usually the right compromise between</span></span><br><span class="line"><span class="comment"># speed and data safety. It's up to you to understand if you can relax this to</span></span><br><span class="line"><span class="comment"># "no" that will let the operating system flush the output buffer when</span></span><br><span class="line"><span class="comment"># it wants, for better performances (but if you can live with the idea of</span></span><br><span class="line"><span class="comment"># some data loss consider the default persistence mode that's snapshotting),</span></span><br><span class="line"><span class="comment"># or on the contrary, use "always" that's very slow but a bit safer than</span></span><br><span class="line"><span class="comment"># everysec.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># More details please check the following article:</span></span><br><span class="line"><span class="comment"># http://antirez.com/post/redis-persistence-demystified.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If unsure, use "everysec".</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec</span></span><br><span class="line"><span class="comment"># appendfsync no</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>no-appendfsync-on-rewriteAOFredis：在进行aof重写时，不阻塞主进程对客户端的请求。</p>
<p>使用aof随着时间推移，文件会越来越大，因此，Redis还有一个rewrite策略，实现AOF文件的减肥，但是结果的幂等的。<code>no-appendfsync-on-rewrite</code>的策略是 <code>no</code>. 这就会导致在进行rewrite操作时，<code>appendfsync</code>会被阻塞。如果当前AOF文件很大，那么相应的rewrite时间会变长，<code>appendfsync</code>被阻塞的时间也会更长。</p>
</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># When the AOF fsync policy is set to always or everysec, and a background</span></span><br><span class="line"><span class="comment"># saving process (a background save or AOF log background rewriting) is</span></span><br><span class="line"><span class="comment"># performing a lot of I/O against the disk, in some Linux configurations</span></span><br><span class="line"><span class="comment"># Redis may block too long on the fsync() call. Note that there is no fix for</span></span><br><span class="line"><span class="comment"># this currently, as even performing fsync in a different thread will block</span></span><br><span class="line"><span class="comment"># our synchronous write(2) call.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to mitigate this problem it's possible to use the following option</span></span><br><span class="line"><span class="comment"># that will prevent fsync() from being called in the main process while a</span></span><br><span class="line"><span class="comment"># BGSAVE or BGREWRITEAOF is in progress.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This means that while another child is saving, the durability of Redis is</span></span><br><span class="line"><span class="comment"># the same as "appendfsync none". In practical terms, this means that it is</span></span><br><span class="line"><span class="comment"># possible to lose up to 30 seconds of log in the worst scenario (with the</span></span><br><span class="line"><span class="comment"># default Linux settings).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you have latency problems turn this to "yes". Otherwise leave it as</span></span><br><span class="line"><span class="comment"># "no" that is the safest pick from the point of view of durability.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">no-appendfsync-on-rewrite</span> <span class="string">no</span></span><br></pre></td></tr></table></figure>

<ul>
<li>何时重写</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Automatic rewrite of the append only file.</span></span><br><span class="line"><span class="comment"># Redis is able to automatically rewrite the log file implicitly calling</span></span><br><span class="line"><span class="comment"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is how it works: Redis remembers the size of the AOF file after the</span></span><br><span class="line"><span class="comment"># latest rewrite (if no rewrite has happened since the restart, the size of</span></span><br><span class="line"><span class="comment"># the AOF at startup is used).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This base size is compared to the current size. If the current size is</span></span><br><span class="line"><span class="comment"># bigger than the specified percentage, the rewrite is triggered. Also</span></span><br><span class="line"><span class="comment"># you need to specify a minimal size for the AOF file to be rewritten, this</span></span><br><span class="line"><span class="comment"># is useful to avoid rewriting the AOF file even if the percentage increase</span></span><br><span class="line"><span class="comment"># is reached but it is still pretty small.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Specify a percentage of zero in order to disable the automatic AOF</span></span><br><span class="line"><span class="comment"># rewrite feature.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="meta">auto-aof-rewrite-min-size</span> <span class="string">64mb</span></span><br></pre></td></tr></table></figure>

<h4 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h4><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof。</p>
<h5 id="Redis如何实现重写"><a href="#Redis如何实现重写" class="headerlink" title="Redis如何实现重写"></a>Redis如何实现重写</h5><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。</p>
<h5 id="何时重写"><a href="#何时重写" class="headerlink" title="何时重写"></a>何时重写</h5><p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。</p>
<p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。</p>
<h4 id="AOF的备份与恢复"><a href="#AOF的备份与恢复" class="headerlink" title="AOF的备份与恢复"></a>AOF的备份与恢复</h4><p>备份：AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件(AOF文件的保存路径，同RDB的路径一致)，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p>
<p>文件损坏恢复：如遇到AOF文件损坏，可通过<code>redis-check-aof --fix appendonly.aof</code>进行恢复</p>
<h4 id="AOF的优缺点"><a href="#AOF的优缺点" class="headerlink" title="AOF的优缺点"></a>AOF的优缺点</h4><p>优点:</p>
<ul>
<li>备份机制更稳健，丢失数据概率更低。</li>
<li>可读的日志文本，通过操作AOF稳健，可以处理误操作。</li>
</ul>
<p>缺点:</p>
<ul>
<li>比起RDB占用更多的磁盘空间</li>
<li>恢复备份速度要慢</li>
<li>每次读写都同步的话，有一定的性能压力。</li>
</ul>
<h3 id="RDB和AOF的选择"><a href="#RDB和AOF的选择" class="headerlink" title="RDB和AOF的选择"></a>RDB和AOF的选择</h3><p>官方推荐两个都启用。</p>
<p>如果对数据不敏感，可以选单独用RDB。</p>
<p>不建议单独用 AOF，因为可能会出现Bug。</p>
<p>如果只是做纯内存缓存，可以都不用。</p>
<h4 id="RDB和AOF同时开启听谁的"><a href="#RDB和AOF同时开启听谁的" class="headerlink" title="RDB和AOF同时开启听谁的"></a>RDB和AOF同时开启听谁的</h4><p>AOF和RDB同时开启，系统默认取AOF的数据</p>
<p>推荐阅读：<a href="https://www.jianshu.com/p/9cdf6c6d4cb0" target="_blank" rel="noopener">黑猴子的家：Redis 持久化 之 AOF 和 RDB 同时开启，Redis听谁的？</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://liudanking.com/performance/一次非典型性-redis-阻塞总结/" target="_blank" rel="noopener">一次非典型性Redis 阻塞总结| 行思錄| Travel Coder</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/48535300" target="_blank" rel="noopener">进阶的Redis之数据持久化RDB与AOF</a></li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>pandaaaaaa</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://yoursite.com/redis01%20%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/">http://yoursite.com/redis01%20%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Redis-NoSql/"># Redis,NoSql</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/springboot09%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E5%99%A8/">springboot09 自定义启动器</a>
            
        </section>
        <section>
            <div class="comment" style="clear: both; margin-top: 38;"></div>
        </section>
    
    </article>
    
        <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="/js/valine.min.js"></script>


<script>
    new Valine({
        // AV 对象来自上面引入av-min.js(老司机们不要开车➳♡゛扎心了老铁)
        av: AV, 
        el: '.comment',
	      lang: '',//设置评论语言
        emoticon_url: 'https://cloud.panjunwen.com/alu',
  emoticon_list: ["狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","暗地观察.png"],
  app_id: 'TmbiNFkUq1bDjqdBf25VTp3b-MdYXbMMI',
  app_key: 'dBwYjVpP5M0dq0sQVwznG13I',
  placeholder: 'Write a Comment'
    });
</script>

<!--
<script>
  new Valine({
      el: '.comment',
      notify: true,
      verify: false,
      app_id: 'TmbiNFkUq1bDjqdBf25VTp3b-MdYXbMMI',
      app_key: 'dBwYjVpP5M0dq0sQVwznG13I',
      lang: 'en',
      placeholder: 'Write a Comment',
      avatar: 'monsterid',
      visitor: true
        });
</script>
-->
        
</div>


        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© pandaaaaaa | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
